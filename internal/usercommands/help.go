package usercommands

import (
	"fmt"
	"os"
	"regexp"
	"sort"
	"strings"

	"github.com/GoMudEngine/GoMud/internal/configs"
	"github.com/GoMudEngine/GoMud/internal/events"
	"github.com/GoMudEngine/GoMud/internal/keywords"
	"github.com/GoMudEngine/GoMud/internal/llm"
	"github.com/GoMudEngine/GoMud/internal/mudlog"
	"github.com/GoMudEngine/GoMud/internal/races"
	"github.com/GoMudEngine/GoMud/internal/rooms"
	"github.com/GoMudEngine/GoMud/internal/spells"
	"github.com/GoMudEngine/GoMud/internal/templates"
	"github.com/GoMudEngine/GoMud/internal/users"
	"github.com/GoMudEngine/GoMud/internal/util"
)

// Initialize the LLM help system on first use rather than during init
var llmInitialized bool = false

func ensureLLMInitialized() {
	if !llmInitialized {
		llm.InitHelpLLM()
		llmInitialized = true
	}
}

func Help(rest string, user *users.UserRecord, room *rooms.Room, flags events.EventFlag) (bool, error) {

	var helpTxt string
	var err error = nil

	args := util.SplitButRespectQuotes(rest)

	if len(args) == 0 {

		type helpCommand struct {
			Command string
			Type    string
			Missing bool
		}

		type commandLists struct {
			Commands map[string][]helpCommand
			Skills   map[string][]helpCommand
			Admin    map[string][]helpCommand
		}

		helpCommandList := commandLists{
			Commands: make(map[string][]helpCommand),
			Skills:   make(map[string][]helpCommand),
			Admin:    make(map[string][]helpCommand),
		}

		for _, command := range keywords.GetAllHelpTopicInfo() {

			category := command.Category
			if category == `all` {
				category = ``
			}

			templateFile := `help/` + keywords.TryHelpAlias(command.Command)

			if command.AdminOnly {
				if user.HasRolePermission(command.Command, true) {
					helpCommandList.Admin[category] = append(
						helpCommandList.Admin[category],
						helpCommand{Command: command.Command, Type: "command-admin", Missing: false},
					)
				}
				continue
			}

			hlpCmd := helpCommand{Command: command.Command, Type: command.Type, Missing: !templates.Exists(templateFile)}

			if command.Type == `skill` {
				helpCommandList.Skills[category] = append(helpCommandList.Skills[category], hlpCmd)
				continue
			}

			helpCommandList.Commands[category] = append(helpCommandList.Commands[category], hlpCmd)

		}

		helpTxt, err = templates.Process("help/help", helpCommandList, user.UserId)
		if err != nil {
			helpTxt = err.Error()
		}
	} else {

		helpName := args[0]
		helpRest := ``

		args := args[1:]
		if len(args) > 0 {
			helpRest = strings.Join(args, ` `)
		}

		// replace any non alpha/numeric characters in "rest"
		if fullSearchAlias := keywords.TryHelpAlias(rest); fullSearchAlias != rest {
			helpName = fullSearchAlias
		} else {
			helpName = regexp.MustCompile(`[^a-zA-Z0-9\\-]+`).ReplaceAllString(helpName, ``)
			helpName = keywords.TryHelpAlias(helpName)
		}

		var helpVars any = nil

		if helpName == `emote` {
			helpVars = emoteAliases
		}

		if helpName == `races` {
			helpVars = getRaceOptions(helpRest)
		}

		if helpName == `spell` {
			sData := spells.GetSpell(helpRest)
			if sData == nil {
				sData = spells.FindSpellByName(helpRest)
			}

			if sData == nil {
				helpName = `spells`
			} else {
				helpVars = *sData
			}
		}

		// First try to use a template
		helpTxt, err = templates.Process("help/"+helpName, helpVars, user.UserId)

		// If template not found, check if we can use LLM-based help
		if err != nil {
			// For multi-word queries, always use LLM
			if strings.Contains(strings.TrimSpace(rest), " ") {
				mudlog.Info("help-debug", "multi_word_query", "Multi-word query, using LLM directly", "query", rest)
				// Skip template checking for multi-word queries
			} else {
				// For single-word queries, check for cached template first
				// Check if there's an auto-generated template already
				autoTemplateName := llm.GetAutoGeneratedTemplateName(rest)

				// Check if .md file exists in the filesystem directly
				// NOTE: The templates are saved to "templates/help/auto/*.md", not in datafiles
				autoTemplateFile := "templates/help/auto/" + sanitizeFilename(rest) + ".md"

				// Add debug log
				mudlog.Info("help-debug", "checking_file", autoTemplateFile, "query", rest)

				// Check if the auto-generated markdown file exists
				if _, fileErr := os.Stat(autoTemplateFile); fileErr == nil {
					mudlog.Info("help-debug", "found_md_file", autoTemplateFile)

					// Read the file content directly
					mdContent, mdErr := os.ReadFile(autoTemplateFile)
					if mdErr == nil {
						// Use the content directly
						helpTxt = string(mdContent)
						err = nil
						mudlog.Info("help-debug", "using_md_file", "success")
						user.SendText(helpTxt)
						return true, nil
					} else {
						mudlog.Warn("help-debug", "md_file_read_error", mdErr.Error(), "file", autoTemplateFile)
					}
				} else {
					mudlog.Info("help-debug", "md_file_not_found", autoTemplateFile, "error", fileErr.Error())

					// Also try the templates.Exists method (which may not work with .md files)
					if templates.Exists(autoTemplateName) {
						mudlog.Info("help-debug", "found_template", autoTemplateName)
						helpTxt, err = templates.Process(autoTemplateName, nil, user.UserId)
						if err == nil {
							user.SendText(helpTxt)
							return true, nil
						}
						mudlog.Warn("help-debug", "template_process_error", err.Error(), "template", autoTemplateName)
					} else {
						mudlog.Info("help-debug", "template_not_found", autoTemplateName)
					}
				}
			}

			// Only try LLM if no template was found or if it's a multi-word query
			intConfig := configs.GetIntegrationsConfig()
			if intConfig.LLMHelp.Enabled {
				// Initialize LLM if needed
				ensureLLMInitialized()

				// Get the list of available commands for context
				var availableCommands []string
				for _, cmd := range keywords.GetAllHelpTopicInfo() {
					if !cmd.AdminOnly || user.HasRolePermission(cmd.Command, true) {
						availableCommands = append(availableCommands, cmd.Command)
					}
				}

				// Try to get response from LLM
				llmResponse, llmErr := llm.GetHelpResponse(rest, availableCommands, user.UserId)
				if llmErr == nil {
					helpTxt = llmResponse
					err = nil
					mudlog.Info("help-llm", "query", rest, "found", "true")
				} else {
					mudlog.Warn("help-llm", "response", llmResponse, "query", rest, "error", llmErr.Error())
				}
			} else {
				// Log that LLM is disabled
				mudlog.Info("help-llm", "status", "disabled", "config", intConfig.LLMHelp.Enabled)
				user.SendText(fmt.Sprintf("Note: LLM help is disabled in configuration (Enabled=%v)", intConfig.LLMHelp.Enabled))
			}

			// If we still have no response, use the default error message
			if err != nil {
				helpTxt = fmt.Sprintf(`No help found for "%s"`, helpName)
			}
		}
	}

	user.SendText(helpTxt)

	return true, nil
}

func getRaceOptions(raceRequest string) []races.Race {

	allRaces := races.GetRaces()
	sort.Slice(allRaces, func(i, j int) bool {
		return allRaces[i].RaceId < allRaces[j].RaceId
	})

	raceNames := strings.Split(raceRequest, ` `)

	getAllRaces := false
	if raceRequest == `all` {
		getAllRaces = true
	}

	raceOptions := []races.Race{}
	for _, race := range allRaces {

		if len(raceRequest) == 0 {
			if !race.Selectable && !getAllRaces {
				continue
			}
		} else if len(raceNames) > 0 {
			lowerName := strings.ToLower(race.Name)
			found := false
			for _, rName := range raceNames {
				if strings.Contains(lowerName, strings.ToLower(rName)) {
					found = true
					break
				}
			}
			if !getAllRaces && !found {
				continue
			}
		}
		raceOptions = append(raceOptions, race)
	}

	return raceOptions
}

// sanitizeFilename creates a valid filename from a query string
// This matches the function in internal/llm/help.go
func sanitizeFilename(query string) string {
	// Convert to lowercase
	name := strings.ToLower(query)

	// Replace spaces with hyphens
	name = strings.ReplaceAll(name, " ", "-")

	// Remove any characters that aren't alphanumeric, hyphens, or underscores
	name = strings.Map(func(r rune) rune {
		if (r >= 'a' && r <= 'z') || (r >= '0' && r <= '9') || r == '-' || r == '_' {
			return r
		}
		return -1
	}, name)

	// Limit the length
	if len(name) > 50 {
		name = name[:50]
	}

	// Ensure it's not empty
	if name == "" {
		name = "unknown-query"
	}

	return name
}
